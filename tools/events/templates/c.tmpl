// Â© 2021 Qualcomm Innovation Center, Inc. All rights reserved.
//
// 2019 Cog Systems Pty Ltd.
//
// SPDX-License-Identifier: BSD-3-Clause
// This file is automatically generated.
#set empty=True

\#include <hyptypes.h>
\#include <compiler.h>
#for i in $includes
\#include $i
#end for
#if $extra_includes

#end if
#for i in $extra_includes
\#include <$i>
#end for

\#include <events/${name}.h>
#for h in $declared_handlers
#set empty=False

#set noreturn = 'noreturn ' if $h.noreturn else ''
$noreturn$h.return_type
${h.name}(#slurp
#set sep = ''
#set params = list($h.params)
#if $params
#for p in $params
#set space = '' if p.type.endswith('*') else ' '
${sep}${p.type}${space}${p.name}#slurp
#set sep=', '
#end for
#else
void#slurp
#end if
)#slurp
#for l in $h.lock_opts
 ${l.action.upper()}_${l.kind.upper()}(${l.lock})#slurp
#end for
;
#end for
#def prototype(e)
#set noreturn = 'noreturn ' if $e.noreturn else ''
$noreturn$e.return_type
trigger_${e.name}_event(#slurp
#set sep = ''
#if $e.params
#for p in $e.params
#set space = '' if p.type.endswith('*') else ' '
${sep}${p.type}${space}${p.name}#slurp
#set sep=', '
#end for
#else
void#slurp
#end if
)#slurp
#end def
#def call(s, r)
#if r is not None
#set ret_assign = r + ' = '
#else
#set ret_assign = ''
#end if
#if s.handler is not None
#if s.handler.noreturn
${s.handler.name}(${', '.join(s.handler.args)})#slurp
#else
$ret_assign${s.handler.name}(${', '.join(s.handler.args)})#slurp
#end if
#elif s.constant is not None
$ret_assign${s.constant}#slurp
#else
#raise Exception("No handler or constant for subscription " + str($s))
#end if
#end def
#for e in $simple_events

$prototype(e)
{
#for p in sorted(e.unused_param_names)
    (void)$p;
#end for
#for s in e.subscribers
    $call(s, None);
#end for
}
#end for
#for e in $handled_events

$prototype(e)
{
#for p in sorted(e.unused_param_names)
    (void)$p;
#end for
#if e.subscribers
    $e.return_type ret;

#for s in e.subscribers
    $call(s, 'ret');
    if (ret != $e.default) {
        goto out;
    }

#end for
out:
    return ret;
#else
    return $e.default;
#end if
}
#end for
#for e in $multi_events

$prototype(e)
{
#for p in sorted(e.unused_param_names)
    (void)$p;
#end for
#if e.subscribers
    $e.count.type _ret;
#end if
#for s in e.subscribers
    $call(s, '_ret');
    if (_ret >= $e.count.name) {
        return ($e.count.type)0;
    }
    $e.count.name -= _ret;
#end for
    return $e.count.name;
}
#end for
#for e in $setup_events

$prototype(e)
{
#for p in sorted(e.unused_param_names)
    (void)$p;
#end for
    $e.result.type $e.result.name = $e.result.default;

#set indent = ' '*4
#set first = True
#for s in e.subscribers
#if first
#set first = False
#else
${indent}if (compiler_expected($e.result.name == $e.success)) {
#set indent = indent + ' '*4
#end if
${indent}$call(s, $e.result.name);
#end for

#for s in tuple(reversed(e.subscribers))[1:]
#if s.unwinder is not None
${indent}if (compiler_unexpected($e.result.name != $e.success)) {
${indent}    ${s.unwinder.name}(${', '.join(s.unwinder.args)});
${indent}}
#end if
#set indent = indent[:-4]
${indent}}
#end for

    return $e.result.name;
}
#end for
#for e in $selector_events
#set void=$e.return_type=='void'

\#pragma clang diagnostic push
\#pragma clang diagnostic ignored "-Wswitch-enum"

$prototype(e)
{
#for p in sorted(e.unused_param_names)
    (void)$p;
#end for
#if not $void
    $e.return_type ret;
#set ret='ret'
#else
#set ret=None
#end if
    switch ($e.selector.name) {
#for s in e.subscribers
#for selector in $s.selectors
    case $selector:
#end for
        $call(s, ret);
#if s.handler and s.handler.noreturn
        // ${s.handler}() does not return
        compiler_unreachable_break;
#else
        break;
#end if
#end for
    default:
#if $void
	// Nothing to do
#else
        $ret = $e.result.default;
#end if
        break;
    }

#if not $void
    return ret;
#end if
}

\#pragma clang diagnostic pop
#end for
#if empty
void
${name}_events_dummy_function(void);
#end if
